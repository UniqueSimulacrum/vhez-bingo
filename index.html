<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vhezly's Horror Bingo</title>
  <link rel="stylesheet" href="style.css">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&family=Saira+Extra+Condensed:wght@100;200;300;400;500;600;700;800;900&display=swap" rel="stylesheet">
</head>
<body>
  <div class="app">

    <div class="card">
      <h1 id="title" class="title"></h1>
      <div id="grid" class="grid" aria-label="5x5 Bingo Feld"></div>

      <div class="controls">
        

        <div class="buttons">
          <label class="toggle" title="Mitte als Jokerfeld verwenden">
            <span>Joker</span>
            <div class="switch">
              <input id="jokerToggle" type="checkbox" aria-label="Joker aktivieren" />
              <span class="slider"></span>
            </div>
          </label>
          <button id="fillBtn" type="button">Zuf√§llig f√ºllen</button>
          <button id="startBtn" type="button" disabled>Start</button>
        </div>
        <div id="status" class="hint"></div>
      </div>
    </div>
  </div>
  <div class="firework"></div>
  <div id="toast"></div>
  <script>
    const MAX_NUMBER = 66;

    const SIZE = 5;

    const TITLE = "BULLSHIT BINGO"
    
    const gridEl = document.getElementById('grid');
    const jokerToggle = document.getElementById('jokerToggle');
    const fillBtn = document.getElementById('fillBtn');
    const startBtn = document.getElementById('startBtn');
    const statusEl = document.getElementById('status');
    const title = document.getElementById('title');

    const MID = Math.floor((SIZE*SIZE)/2);
    let started = false;

    // Keep this outside checkBingo() so it persists between calls
    const rewardedBingos = new Set();

    title.textContent = TITLE;
    const grid = document.querySelector(".grid");
    grid.style.gridTemplateColumns = `repeat(${SIZE}, 1fr)`;

    const cells = Array.from({ length: SIZE*SIZE }, (_, i) => createCell(i));

    function createCell(index) {
      const wrapper = document.createElement('div');
      wrapper.className = 'cell';
      wrapper.dataset.index = index;

      const input = document.createElement('input');
      input.type = 'number';
      input.inputMode = 'numeric';
      input.autocomplete = 'off';
      input.placeholder = '';
      input.title = 'Nur Zahlen';

      input.addEventListener('input', () => {
        if (input.value.includes('e') || input.value.includes('E')) input.value = '';
        validateAll();
      });

      wrapper.appendChild(input);
      gridEl.appendChild(wrapper);
      return { wrapper, input };
    }

    function applyJokerState() {
      const on = jokerToggle.checked;
      const mid = cells[MID];
      if (on) {
        mid.input.value = '';
        mid.input.readOnly = true;
        mid.wrapper.classList.add('joker');
      } else {
        if (!started) mid.input.readOnly = false;
        mid.wrapper.classList.remove('joker');
      }
      validateAll();
    }

    jokerToggle.addEventListener('change', applyJokerState);

    function randomFill() {
      const pool = Array.from({length: MAX_NUMBER}, (_, i) => i+1);
      shuffle(pool);
      let ptr = 0;
      for (let i = 0; i < cells.length; i++) {
        if (jokerToggle.checked && i === MID) continue;
        const c = cells[i];
        c.input.value = pool[ptr++];
      }
      validateAll();
    }

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }

    function validateAll() {
      const map = new Map();
      const consider = (i) => !(jokerToggle.checked && i === MID);

      let hasOutOfRange = false;

      for (let i = 0; i < cells.length; i++) {
        const value = cells[i].input.value.trim();
        cells[i].wrapper.classList.remove('dup', 'outofrange');
        if (!consider(i)) continue;
        if (value !== '') {
          const num = parseInt(value);
          if (isNaN(num) || num < 1 || num > MAX_NUMBER) {
            cells[i].wrapper.classList.add('outofrange');
            hasOutOfRange = true;
          }
          map.set(value, (map.get(value) || []).concat(i));
        }
      }

      let hasDup = false;
      map.forEach((indices) => {
        if (indices.length > 1) {
          hasDup = true;
          indices.forEach(idx => cells[idx].wrapper.classList.add('dup'));
        }
      });

      let complete = true;
      for (let i = 0; i < cells.length; i++) {
        if (!consider(i)) continue;
        if (cells[i].input.value.trim() === '') { complete = false; break; }
      }

      if (hasOutOfRange) {
        statusEl.textContent = `Fehler: Zahlen m√ºssen zwischen 1 und ${MAX_NUMBER} liegen.`;
      } else if (hasDup) {
        statusEl.textContent = 'Fehler: Duplikate gefunden. Bitte korrigieren.';
      } else if (!complete) {
        statusEl.textContent = `Bitte alle Felder mit Zahlen von 1 bis ${MAX_NUMBER} f√ºllen.`;
      } else {
        statusEl.textContent = 'Bereit zum Start.';
      }
      startBtn.disabled = hasDup || hasOutOfRange || !complete || started;
    }

    function startGame() {
      started = true;
      for (let i = 0; i < cells.length; i++) {
        if (jokerToggle.checked && i === MID) {
        } else {
          cells[i].input.readOnly = true;
        }
      }
      statusEl.textContent = 'Spiel l√§uft: Klicke Felder zum Markieren.';
      startBtn.textContent = 'Neustart';
      startBtn.disabled = false;
      jokerToggle.disabled = true;
      gridEl.addEventListener('click', onCellClick);
      document.body.classList.add("started");
    }

    function resetGame(keepNumbers = false) {
      started = false;
      cells.forEach((c, i) => {
        if (!keepNumbers) {
          c.input.value = '';
        }
        c.input.readOnly = false;
        c.wrapper.classList.remove('marked', 'bingo', 'dup', 'outofrange');
      });
      jokerToggle.disabled = false;
      startBtn.textContent = 'Start';
      startBtn.disabled = true;
      statusEl.textContent = '';
      statusEl.classList.remove('bingo-message','bingo-animate');
      
      rewardedBingos.clear(); // üî• allow new bingos & fireworks again
      applyJokerState();
      validateAll();
    }

    function onCellClick(e) {
      if (!started) return;
      const cell = e.target.closest('.cell');
      if (!cell) return;
      cell.classList.toggle('marked');
      checkBingo();
    }

    function checkBingo() {
      // Reset highlighting before re-check
      cells.forEach(c => c.wrapper.classList.remove('bingo'));

      const lines = [];

      // Rows
      for (let r = 0; r < SIZE; r++) {
        lines.push({ id: `row-${r}`, idxs: [...Array(SIZE).keys()].map(c => r*SIZE + c) });
      }
      // Cols
      for (let c = 0; c < SIZE; c++) {
        lines.push({ id: `col-${c}`, idxs: [...Array(SIZE).keys()].map(r => r*SIZE + c) });
      }
      // Diagonals
      lines.push({ id: 'diag-main', idxs: [...Array(SIZE).keys()].map(i => i*SIZE + i) });
      lines.push({ id: 'diag-anti', idxs: [...Array(SIZE).keys()].map(i => i*SIZE + (SIZE-1-i)) });

      let newBingos = [];

      for (const { id, idxs } of lines) {
        const isComplete = idxs.every(idx =>
          cells[idx].wrapper.classList.contains('marked') || (jokerToggle.checked && idx === MID)
        );

        if (isComplete) {
          // highlight
          idxs.forEach(idx => cells[idx].wrapper.classList.add('bingo'));

          // if not already rewarded ‚Üí add to newBingos
          if (!rewardedBingos.has(id)) {
            rewardedBingos.add(id);

            const values = idxs.map(idx =>
              cells[idx].input.value || (idx === MID ? 'Joker' : '')
            ).join(', ');

            newBingos.push(`Bingo! Linie: ${values}`);
          }
        }
      }

      if (newBingos.length) {
        newBingos.forEach(msg => showToast(msg));
        triggerFirework();
      }
    }

    fillBtn.addEventListener('click', () => { if (!started) randomFill(); });
    startBtn.addEventListener('click', () => {
      if (!started) {
        startGame();
      } else {
        // Show dialog
        const reuse = window.confirm("Soll das Board mit den gleichen Zahlen neu gestartet werden?\n\nOK = Behalten\nAbbrechen = Leeren");
        resetGame(reuse); 
      }
    });

    function triggerFirework() {
      const fw = document.querySelector('.firework');
      fw.classList.add('active');

      fw.addEventListener('animationend', () => {
        fw.classList.remove('active');
      }, { once: true });
    }

    function showToast(message) {
      const toast = document.createElement("div");
      toast.className = "toast show";
      toast.textContent = message;

      // find or create toast container
      let container = document.querySelector(".toast-container");
      if (!container) {
        container = document.createElement("div");
        container.className = "toast-container";
        document.body.appendChild(container);
      }

      container.appendChild(toast);

      // auto-remove after 3s
      setTimeout(() => {
        toast.classList.remove("show");
        setTimeout(() => toast.remove(), 500);
      }, 3000);
    }

    applyJokerState();
    validateAll();
  </script>
</body>
</html>
